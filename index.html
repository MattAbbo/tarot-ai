<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TAROT AI</title>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons - Add these two lines -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <script>lucide.createIcons();</script>
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Constants -->
    <script src="/src/constants/messages.js"></script>
    
    <!-- Components -->
    <script src="/src/components/Header.js" type="text/babel"></script>
    <script src="/src/components/MessageBubble.js" type="text/babel"></script>
    <script src="/src/components/DrawButton.js" type="text/babel"></script>
    <script src="/src/components/InputSection.js" type="text/babel"></script>
    
    <!-- Styles -->
    <style>
        body { 
            background: #1a1a2e; 
            margin: 0;
            min-height: 100vh;
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .font-cinzel {
            font-family: 'Cinzel', serif;
        }

        #root {
            height: 100%;
        }
    </style>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        mystic: {
                            900: '#1a1a2e',
                            800: '#232338',
                            700: '#2d2d45',
                        },
                        crystal: {
                            500: '#9b6dff',
                            600: '#7e57c2',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Main App -->
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
    
        function TarotChat() {
            const [messages, setMessages] = useState([{
                id: '1',
                content: MESSAGES.welcome,
                type: 'ai'
            }]);
            const [isLoading, setIsLoading] = useState(false);
            const [currentState, setState] = useState('initial');
            const [input, setInput] = useState('');
            const [isRecording, setIsRecording] = useState(false);
            const [recordingTime, setRecordingTime] = useState(0);
            const [currentCard, setCurrentCard] = useState(null);
    
            const mediaRecorderRef = useRef(null);
            const timerRef = useRef(null);
            const audioChunksRef = useRef([]);

            const handleMainButton = async () => {
                switch(currentState) {
                    case 'reflection':
                        await handleRevealInterpretation();
                        break;
                    case 'complete':
                        startNewReading();
                        break;
                    default:
                        await handleDrawCard();
                }
            };
    
            useEffect(() => {
                if (isRecording) {
                    timerRef.current = setInterval(() => {
                        setRecordingTime(t => t + 1);
                    }, 1000);
                }
                return () => clearInterval(timerRef.current);
            }, [isRecording]);
    
            const startRecording = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mediaRecorder = new MediaRecorder(stream);
                    mediaRecorderRef.current = mediaRecorder;
                    audioChunksRef.current = [];
    
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunksRef.current.push(event.data);
                    };
    
                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
                        await handleAudioTranscription(audioBlob);
                    };
    
                    setIsRecording(true);
                    setRecordingTime(0);
                    mediaRecorder.start();
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                }
            };
    
            const stopRecording = () => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                    mediaRecorderRef.current.stop();
                    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
                    clearInterval(timerRef.current);
                    setIsRecording(false);
                }
            };
    
            const cancelRecording = () => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                    mediaRecorderRef.current.stop();
                    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
                    clearInterval(timerRef.current);
                    setIsRecording(false);
                    audioChunksRef.current = [];
                }
            };
    
            const handleAudioTranscription = async (audioBlob) => {
                try {
                    setIsLoading(true);
                    const formData = new FormData();
                    formData.append('audio_file', audioBlob, 'recording.wav');
    
                    const response = await fetch('/transcribe', {
                        method: 'POST',
                        body: formData
                    });
    
                    if (!response.ok) throw new Error('Transcription failed');
                    
                    const data = await response.json();
                    setInput(data.transcription);
                } catch (error) {
                    console.error('Transcription error:', error);
                } finally {
                    setIsLoading(false);
                }
            };
    
            const handleInput = async () => {
                if (isLoading || !input.trim()) return;
    
                if (currentState === 'reflection') {
                    await handleRevealInterpretation();
                } else {
                    await handleDrawCard();
                }
            };
    
            const handleDrawCard = async () => {
                if (isLoading) return;
                
                try {
                    setIsLoading(true);
                    const userInput = input.trim();
                    
                    if (userInput) {
                        setMessages(prev => [...prev, {
                            id: Date.now().toString(),
                            content: userInput,
                            type: 'user'
                        }]);
                    }
    
                    const drawingMessage = MESSAGES.drawing[
                        Math.floor(Math.random() * MESSAGES.drawing.length)
                    ];
                    
                    setMessages(prev => [...prev, {
                        id: Date.now().toString(),
                        content: drawingMessage,
                        type: 'ai'
                    }]);
    
                    await new Promise(resolve => setTimeout(resolve, 1500));
    
                    const response = await fetch('/reading', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ context: userInput }),
                    });
    
                    if (!response.ok) throw new Error('Reading failed');
                    const data = await response.json();
                    
                    setCurrentCard({
                        name: data.card_name,
                        image: data.image_data,
                        originalContext: userInput
                    });
    
                    setMessages(prev => [
                        ...prev.filter(m => m.content !== drawingMessage),
                        {
                            id: Date.now().toString(),
                            content: data.card_name,
                            type: 'card',
                            card: {
                                name: data.card_name,
                                image: data.image_data
                            }
                        },
                        {
                            id: (Date.now() + 1).toString(),
                            content: data.reflection_prompt,
                            type: 'ai'
                        }
                    ]);
    
                    setState('reflection');
                    setInput('');
                } catch (error) {
                    console.error('Error:', error);
                    setMessages(prev => [...prev, {
                        id: Date.now().toString(),
                        content: MESSAGES.error,
                        type: 'ai'
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };
    
            const handleRevealInterpretation = async () => {
                if (isLoading || !currentCard) return;

                try {
                    setIsLoading(true);
                    const userReflection = input.trim();
                    
                    if (userReflection) {
                        setMessages(prev => [...prev, {
                            id: Date.now().toString(),
                            content: userReflection,
                            type: 'user'
                        }]);
                    }

                    const loadingMessage = MESSAGES.loading[
                        Math.floor(Math.random() * MESSAGES.loading.length)
                    ];
                    
                    setMessages(prev => [...prev, {
                        id: Date.now().toString(),
                        content: loadingMessage,
                        type: 'ai'
                    }]);

                    const fullContext = `${currentCard.originalContext || ''} CARD: ${currentCard.name}`;

                    const response = await fetch('/reading', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            context: fullContext,
                            reflection: userReflection || ' '
                        }),
                    });

                    if (!response.ok) throw new Error('Reading failed');
                    const data = await response.json();
                    
                    setMessages(prev => {
                        const newMessages = [...prev];
                        // Remove loading message
                        return newMessages.filter(m => m.content !== loadingMessage).concat({
                            id: Date.now().toString(),
                            content: data.interpretation,
                            type: 'ai'
                        });
                    });

                    setState('complete');  // Set state to complete after interpretation
                    setInput('');  // Clear input

                } catch (error) {
                    console.error('Error:', error);
                    setMessages(prev => [...prev, {
                        id: Date.now().toString(),
                        content: MESSAGES.error,
                        type: 'ai'
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const startNewReading = () => {
                setState('initial');
                setCurrentCard(null);
                setInput('');
                setMessages([{
                    id: Date.now().toString(),
                    content: MESSAGES.welcome,
                    type: 'ai'
                }]);
            };
    
            return (
                <div className="fixed inset-0 flex flex-col bg-mystic-900">
                    <Header />
                    <div className="flex-1 overflow-y-auto p-4">
                        <div className="max-w-2xl mx-auto space-y-4">
                            {messages.map((message) => (
                                <MessageBubble key={message.id} message={message} />
                            ))}
                        </div>
                    </div>
                    <div className="shrink-0 border-t border-purple-900 bg-mystic-900">
                        <div className="max-w-2xl mx-auto p-4">
                            {/* Remove the flex justify-center div and let button be full width */}
                            <DrawButton 
                                onClick={handleMainButton}
                                disabled={isLoading}
                                state={currentState}
                            />
                            <InputSection 
                                value={input}
                                onChange={setInput}
                                onSubmit={handleInput}
                                state={currentState}
                                isLoading={isLoading}
                                onStartRecording={startRecording}
                                onStopRecording={stopRecording}
                                onCancelRecording={cancelRecording}
                                isRecording={isRecording}
                                recordingTime={recordingTime}
                            />
                        </div>
                    </div>
                </div>
            );
        }
    
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TarotChat />);
    </script>
</head>
<body>
    <div id="root"></div>
</body>
</html>